<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">

<head>
    <meta charset="utf-8" />
    <title>Orchard</title>
    <style>
        @media print {
            @page {
                size: 3508px 2480px;
                margin: 4cm;
            }
        }
    </style>
</head>

<body>
    <script name="canvas" type="text/javascript">

        // canvas w/ hex
        function fullscreenCanvas() {
            let [can, ctx] = makeCanvas(window.innerWidth, window.innerHeight, false)

            document.body.appendChild(can);
            document.body.style.overflow = "hidden";
            document.body.style.margin = "0";
            document.body.style.padding = "0";

            return ctx;
        }

        function makeCanvas(width, height, alpha) {

            let can = document.createElement('canvas');
            let ctx = can.getContext('2d', { alpha });

            ctx.canvas.width = width;
            ctx.canvas.height = height;
            ctx.canvas.style.display = 'inline-block';

            return [can, ctx];
        }
    </script>

    <script type="text/javascript">
        class Rect {
            constructor(x, y, w, h) {
                this.x = x;
                this.y = y;
                this.w = w;
                this.h = h;
            }
        }

        let scale = 1.07;

        let dim = {
            r: scale * 100,
            dist: scale * 300,
            pad: scale * 75,
            mar: scale * 25
        }

        let settings = {
            width: Math.floor(2 * (dim.pad + dim.mar + dim.r) + dim.dist),
            height: Math.floor(2 * (dim.pad + dim.mar + dim.r + dim.dist)),
            r: Math.floor(dim.r),
            positions: calculatePositions(dim),
            margin: Math.floor(dim.mar)
        };

        let cards = generate();

        let lead = 9;
        for (let i = 0; i < 9; ++i) {
            let [can, ctx] = makeCanvas(settings.width, settings.height, true);
            document.body.appendChild(can);
            renderCard(ctx, null, settings);
        }

        for (let card of cards) {
            let [can, ctx] = makeCanvas(settings.width, settings.height, true);
            document.body.appendChild(can);
            renderCard(ctx, card, settings);
        }

        function calculatePositions(dim) {
            let x = Math.floor(dim.pad + dim.mar + dim.r);
            let [ox, oy, dist] = [x, x, Math.floor(dim.dist)]
            return [pos(ox, oy), pos(ox + dist, oy),
            pos(ox, oy + dist), pos(ox + dist, oy + dist),
            pos(ox, oy + 2 * dist), pos(ox + dist, oy + 2 * dist)];
        }

        function pos(x, y) {
            return { x, y };
        }

        function renderCard(ctx, card, settings) {

            function rounded(color, shift, maxShift) {

                let r = (settings.width - maxShift * 2) * .04 + maxShift - shift;

                roundedRect(ctx, .5 + shift, .5 + shift, settings.width - shift * 2, settings.height - shift * 2, r);

                ctx.fillStyle = color;
                ctx.fill();
            }

            // draw outline
            rounded('black', 0, settings.margin);
            rounded('#bbbbbb', 1, settings.margin);
            rounded('#fff', settings.margin, settings.margin);

            if (card == null) { // back

                ctx.clip();

                let y = -settings.r;
                let shift = false;

                let dx = settings.r / 2;
                let dy = settings.r * Math.sqrt(3) / 4;

                while (y < settings.height + settings.r) {

                    let x = -settings.r;

                    while (x < settings.width + settings.r) {
                        let r = settings.r / 3;
                        let xp = x + (shift ? dx / 2 : 0);

                        ctx.fillStyle = '#999'
                        circle(ctx, xp, y, r * 1.1);
                        ctx.fill();
                        ctx.fillStyle = '#fff'
                        circle(ctx, xp, y, r);
                        ctx.fill();

                        ctx.fillStyle = '#999'
                        circle(ctx, xp + dx / 12, y + dy / 6, r / 5);
                        ctx.fill();

                        x += dx;
                    }

                    y += dy;
                    shift = !shift;
                }


                return;
            }

            // draw roundels
            for (let [type, pos] of zip(card, settings.positions)) {

                ctx.save();
                ctx.translate(pos.x, pos.y);
                drawRoundel(ctx, type, settings);

                ctx.restore();
            }
        }

        function drawRoundel(ctx, type, settings) {

            const types = [typeOne, typeTwo, typeThree];

            ctx.save();
            types[type]();
            ctx.restore();

            function typeOne() {

                ctx.fillStyle = '#777';
                ctx.rotate(-Math.PI / 5 / 2);

                for (let i = 0; i < 5; ++i) {
                    circle(ctx, settings.r / 2, 0, 1.05 * settings.r / 2.5);
                    ctx.fill();
                    ctx.rotate(Math.PI * 2 / 5);
                }

                ctx.fillStyle = '#aaa';
                for (let i = 0; i < 5; ++i) {
                    circle(ctx, settings.r / 2, 0, settings.r / 2.5);
                    ctx.fill();
                    ctx.rotate(Math.PI * 2 / 5);
                }

                ctx.fillStyle = '#fff';
                circle(ctx, 0, 0, settings.r / 3);
                ctx.fill();
            }

            function typeTwo() {
                const n = 5;
                const q = .85;

                ctx.fillStyle = '#444';

                for (let i = 0; i < n; ++i) {
                    for (let j = 0; j < i + 1; ++j) {
                        circle(ctx, q * 2 * (j - i / 2) * settings.r / n, q * (2 * i * settings.r / n - settings.r) * Math.sqrt(3) / 2, 1.1 * settings.r / n)
                        ctx.fill();
                    }
                }

                ctx.fillStyle = '#888';

                for (let i = 0; i < n; ++i) {
                    for (let j = 0; j < i + 1; ++j) {
                        circle(ctx, q * 2 * (j - i / 2) * settings.r / n, q * (2 * i * settings.r / n - settings.r) * Math.sqrt(3) / 2, settings.r / n)
                        ctx.fill();
                    }
                }

                ctx.fillStyle = '#bbb';
                for (let i = 0; i < n; ++i) {
                    for (let j = 0; j < i + 1; ++j) {
                        circle(ctx, q * 2 * (j - i / 2) * settings.r / n, q * (2 * i * settings.r / n - settings.r) * Math.sqrt(3) / 2 - 2 * settings.r / n / 5, settings.r / n / 5)
                        ctx.fill();
                    }
                }
            }

            function typeThree() {

                const r = settings.r;
                const a = r * .4;
                const rx = r * 1.03;
                const ax = a * 1.10
                const n = 6;

                ctx.fillStyle = '#888'
                ctx.rotate(Math.PI * 2 / n / 2);

                circle(ctx, 0, 0, rx / 8);
                ctx.fill();

                for (let i = 0; i < n; ++i) {
                    ctx.beginPath();
                    ctx.moveTo(-rx + r, 0)
                    ctx.quadraticCurveTo(ax, -ax, rx, 0);
                    ctx.quadraticCurveTo(ax, ax, -rx + r, 0);
                    ctx.fill();
                    ctx.rotate(Math.PI * 2 / n);
                }


                ctx.fillStyle = '#bbb'

                for (let i = 0; i < n; ++i) {
                    ctx.beginPath();
                    ctx.moveTo(0, 0)
                    ctx.quadraticCurveTo(a, -a, r, 0);
                    ctx.quadraticCurveTo(a, a, 0, 0);
                    ctx.fill();
                    ctx.rotate(Math.PI * 2 / n);
                }


                ctx.fillStyle = '#888'
                circle(ctx, 0, 0, r / 10);
                ctx.fill();
            }
        }

        function drawRoundelColor(ctx, type, settings) {
            const colors = ['#D2042D', '#2b80bb', '#f0d82b'];
            const sizes = [.06, .15, .35];
            const fruitRenderers = [cherry, plum, pear];
            const fruitScatterers = [cherryScatter, plumScatter, pearScatter];

            ctx.fillStyle = colors[type];

            turn(() => fruitScatterers[type](fruitRenderers[type]))

            function cherry() {
                ctx.save();
                ctx.fillStyle = 'white'
                circle(ctx, 0, 0, 1.1 * settings.r * sizes[0]);
                ctx.fill();
                ctx.restore();

                circle(ctx, 0, 0, settings.r * sizes[0]);
                ctx.fill();
            }

            function plum() {
                ctx.save();
                ctx.fillStyle = 'white'
                circle(ctx, 0, 0, 1.1 * settings.r * sizes[1]);
                ctx.fill();
                ctx.restore();
                circle(ctx, 0, 0, settings.r * sizes[1]);
                ctx.fill();
            }

            function pear() {
                ellipse(ctx, 0, 0, settings.r * sizes[2], settings.r * sizes[2] * .9, 0);
                ctx.fill();
                ellipse(ctx, settings.r * sizes[2] / 2, 0, settings.r * sizes[2], settings.r * sizes[2] / 2, 0);
                ctx.fill();
            }

            function turn(cb) {
                ctx.save()
                ctx.rotate(Math.PI * 2 * Math.random())
                cb();
                ctx.restore();
            }

            function cherryScatter(render) {
                const q = 2;

                for (let i = 250; i >= 0; i--) {
                    let d = phylotaxispos(i);
                    ctx.save()
                    ctx.translate(d.x * q, d.y * q);
                    render();
                    ctx.restore()
                }
            }

            function plumScatter(render) {
                const q = 10;

                for (let i = 1; i < 20; ++i) {
                    let d = phylotaxispos(i);
                    ctx.save()
                    ctx.translate(d.x * q, d.y * q);
                    render();
                    ctx.restore()
                }
            }

            function pearScatter(render) {
                const q = 20;
                let n = 5;

                for (let i = 0; i < n; ++i) {

                    let a = Math.PI * 2 * i / n;

                    ctx.save()
                    ctx.rotate(a)
                    ctx.translate(0, settings.r / 2)
                    ctx.rotate(-Math.PI / 2)

                    render();
                    ctx.restore()
                }

                ctx.fillStyle = 'white';
                circle(ctx, 0, 0, settings.r * sizes[2]);
                ctx.fill();
            }
        }

        function phylotaxispos(n) {
            var r = 2 * Math.sqrt(n);
            var p = n * Math.PI * (3 - Math.sqrt(5));

            return pos(r * Math.cos(p), r * Math.sin(p), p);
        }

        function generate() {
            let m = {};[...perm([0, 0, 1, 1, 2, 2])].forEach(p => {
                let str = p.join('');
                let left = p.slice(0, 3).join('');
                let right = p.slice(3);
                if (str.match(/(.)\1/g)?.length < 3 && left != right.reverse().join('') && left != right.join('') && !(str in m) && !([...p].reverse().join('') in m)) m[str] = p
            });
            return Object.values(m);
        }

        function* perm(values) {
            let p = [];
            for (let i = 0; i <= values.length; ++i)p.push(i)
            let i = 1;
            yield [...values]
            while (i < values.length) {
                p[i]--;
                let j = ((i % 2) == 0) ? 0 : p[i];
                [values[j], values[i]] = [values[i], values[j]]
                yield [...values]
                i = 1
                while (p[i] == 0) {
                    p[i] = i
                    ++i
                }
            }
        }

        function roundedRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x, y + radius);
            ctx.lineTo(x, y + height - radius);
            ctx.arcTo(x, y + height, x + radius, y + height, radius);
            ctx.lineTo(x + width - radius, y + height);
            ctx.arcTo(x + width, y + height, x + width, y + height - radius, radius);
            ctx.lineTo(x + width, y + radius);
            ctx.arcTo(x + width, y, x + width - radius, y, radius);
            ctx.lineTo(x + radius, y);
            ctx.arcTo(x, y, x, y + radius, radius);
            ctx.closePath();
        }

        function* zip(a, b) {
            let len = Math.max(a.length, b.length);

            for (let i = 0; i < len; ++i) {
                yield [a[i % a.length], b[i % b.length]]
            }
        }

        function ellipse(ctx, x, y, r1, r2, a) {
            ctx.beginPath()
            ctx.ellipse(x, y, r1, r2, a, 0, 2 * Math.PI);
            ctx.closePath();
        }

        function circle(ctx, x, y, r) {
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.closePath();
        }


    </script>
</body>

</html>