<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">

<head>
    <meta charset="utf-8" />
    <title>Mandelbrot</title>
</head>

<body>
    <script name="canvas" type="text/javascript">
        // canvas w/ hex
        function fullscreenCanvas() {
            let [can, ctx] = makeCanvas(window.innerWidth, window.innerHeight, false)

            document.body.appendChild(can);
            document.body.style.overflow = "hidden";
            document.body.style.margin = "0";
            document.body.style.padding = "0";

            return ctx;
        }

        function makeCanvas(width, height, alpha) {

            let can = document.createElement('canvas');
            let ctx = can.getContext('2d', { alpha });

            ctx.canvas.width = width;
            ctx.canvas.height = height;
            ctx.canvas.style.display = 'block';

            return [can, ctx];
        }
    </script>

    <script name="loop" type="text/javascript">

        function loop(targetFps, fixedUpdate, render) {
            let fixedDelta = 1000 / targetFps;
            let acc = fixedDelta;
            let then = performance.now();

            function tick(now) {
                let delta = now - then;
                acc += delta;
                then = now;
                let doRender = acc >= fixedDelta;
                let reps = 0;

                while (acc >= fixedDelta && ++reps < 20) {
                    acc -= fixedDelta;
                    fixedUpdate(fixedDelta);
                }

                if (reps == 20) acc = 0;

                if (doRender)
                    render(delta);

                requestAnimationFrame(tick);
            }

            tick(then);
        }
    </script>

    <script type="text/javascript">
        const ctx = fullscreenCanvas();

        const w = ctx.canvas.width;
        const h = ctx.canvas.height;
        const ar = w / h;

        const img = ctx.getImageData(0, 0, w, h)

        let colorOffset = Math.random();
        let maxiterations = 500;

        let maxScale = 5;

        let tilequeue = [];
        let updateRequired = true;
        resetRendering();

        ctx.canvas.addEventListener('mousedown', down);
        ctx.canvas.addEventListener('mouseup', up);
        ctx.canvas.addEventListener('mousemove', move);
        ctx.canvas.addEventListener('contextmenu', e => e.preventDefault());
        window.addEventListener('keydown', key)

        let vw = 5;

        let view = new AABB(-vw / 2 - .5, -vw / ar / 2, vw, vw / ar);
        let protoview = null;
        let undoQueue = [];
        let first = true;

        loop(60, update, render);

        function update() {
            if (!updateRequired) return;

            let then = performance.now();
            let tilesRendered = 0;
            while (tilequeue.length > 0) {
                updateRequired = false;
                let tile = tilequeue.shift();

                let q = Math.pow(2, tile.scale);

                let n = 0;
                let black = 0;

                let ox = tile.bb.x;
                let oy = tile.bb.y;
                let mx = ox + tile.bb.w;
                let my = oy + tile.bb.h;
                for (let y = oy; y < my; y += q) {
                    for (let x = ox; x < mx; x += q) {
                        let v = mandlebrot(...screenToView(x + q / 2, y + q / 2));

                        let color = v == maxiterations ? [0, 0, 0] : getRainbowRGB(colorOffset + Math.pow(v / maxiterations, .5));
                        ++n;
                        black += +(v == maxiterations);

                        for (let sx = 0; sx < q; ++sx) {
                            for (let sy = 0; sy < q; ++sy) {
                                let idx = ((y + sy) * w + x + sx) * 4

                                img.data[idx + 0] = color[0] | 0
                                img.data[idx + 1] = color[1] | 0
                                img.data[idx + 2] = color[2] | 0
                                img.data[idx + 3] = 255;
                            }
                        }
                    }
                }

                if (tile.scale > 0) {
                    let w3 = (tile.bb.w / 3) | 0;
                    let h3 = (tile.bb.h / 3) | 0;

                    let tx0 = tile.bb.x;
                    let ty0 = tile.bb.y;
                    let tx1 = tx0 + w3;
                    let ty1 = ty0 + h3;
                    let tx2 = tx1 + w3;
                    let ty2 = ty1 + h3;

                    let v3 = tile.bb.w - w3 * 2;
                    let g3 = tile.bb.h - h3 * 2;

                    if (v3 < 0 && first) {
                        console.log(tile.bb, tx0, tx1, tx2, w3, v3)
                        first = false;
                    }

                    tilequeue.push(new Tile(new AABB(tx1, ty1, w3, h3), tile.scale - 1, 0));

                    tilequeue.push(new Tile(new AABB(tx1, ty0, w3, h3), tile.scale - 1, 0));
                    tilequeue.push(new Tile(new AABB(tx2, ty1, v3, h3), tile.scale - 1, 0));
                    tilequeue.push(new Tile(new AABB(tx1, ty2, w3, g3), tile.scale - 1, 0));
                    tilequeue.push(new Tile(new AABB(tx0, ty1, w3, h3), tile.scale - 1, 0));

                    tilequeue.push(new Tile(new AABB(tx0, ty0, w3, h3), tile.scale - 1, 0));
                    tilequeue.push(new Tile(new AABB(tx2, ty0, v3, h3), tile.scale - 1, 0));
                    tilequeue.push(new Tile(new AABB(tx2, ty2, v3, g3), tile.scale - 1, 0));
                    tilequeue.push(new Tile(new AABB(tx0, ty2, w3, g3), tile.scale - 1, 0));
                }

                if (performance.now() - then > 15) {
                    break;
                }
            }
        }

        function render() {
            ctx.putImageData(img, 0, 0);

            if (protoview != null) {
                ctx.strokeStyle = 'silver';
                ctx.strokeRect(protoview.x + .5, protoview.y + .5, protoview.w, protoview.h);
            }

            let text = scaleFormatted();
            ctx.font = '16pt "Segoe UI"';
            ctx.fillStyle = 'black';
            ctx.fillText(text, 21, ctx.canvas.height - 29)
            ctx.fillStyle = 'white';
            ctx.fillText(text, 20, ctx.canvas.height - 30)

            if (tilequeue.length > 0) updateRequired = true;
        }

        function scaleFormatted() {
            return view.w < 0.01 ? view.w.toExponential(1) : view.w.toFixed(2)
        }

        function mandlebrot(x, y) {
            let a = x;
            let b = y;
            let n = 0;

            while (n++ < maxiterations) {
                let aa = a * a;
                let bb = b * b;
                let twoab = 2 * a * b;

                a = aa - bb + x
                b = twoab + y

                if (aa * aa + bb * bb > 16) { return n }
            }

            return maxiterations;
        }

        function screenToView(x, y) {
            return [
                view.x + x * view.w / w,
                view.y + y * view.h / h
            ]
        }

        function down(e) {
            if (e.button != 0) return;
            protoview = new AABB(e.clientX, e.clientY, 0, 0);
        }

        function move(e) {
            if (protoview != null) {
                protoview.w = e.clientX - protoview.x;
                protoview.h = e.clientY - protoview.y;
            }
        }

        function up(e) {
            if (e.button == 2) {
                undo();
                return;
            }

            if (e.button != 0) return;

            if (protoview == null || protoview.w < 3 || protoview.h < 3) {
                protoview = null;
                return;
            }

            undoQueue.push(view);

            let [ax, ay] = screenToView(protoview.x, protoview.y);
            let [bx, by] = screenToView(protoview.x + protoview.w, protoview.y + protoview.h);

            let cx = (ax + bx) / 2
            let cy = (ay + by) / 2;

            let w = bx - ax;
            let h = by - ay;
            let a = w / h;

            if (ar > a) w = Math.abs(h) * ar * Math.sign(w);
            else h = Math.abs(w) / ar * Math.sign(h);

            view = new AABB(cx - w / 2, cy - h / 2, w, h);
            protoview = null;

            resetRendering();
        }

        function resetRendering() {
            tilequeue = [new Tile(new AABB(0, 0, w, h), maxScale, 0)];
        }

        function key(e) {
            if (e.key == 'Escape') {
                undo();
            }
        }

        function undo() {
            if (undoQueue.length > 0) {
                view = undoQueue.pop();
                resetRendering();
            }
        }

        function getPositiveAngleDiff(a, b) {
            return a < b ? a + 360 - b : a - b
        }

        function getRainbowRGB(num) {
            let angle = num * 360
            let components = []
            for (let i = 0; i < 3; ++i) {
                let startAngle = ((i + 1) * 120) % 360
                let diffFromStart = getPositiveAngleDiff(angle, startAngle)
                if (diffFromStart < 60)
                    components[i] = diffFromStart / 60 * 255
                else if (diffFromStart <= 180)
                    components[i] = 255
                else if (diffFromStart < 240)
                    components[i] = (240 - diffFromStart) / 60 * 255
                else
                    components[i] = 0
            }
            return components
        }

        function AABB(x, y, w, h) {
            this.x = x;
            this.y = y;
            this.w = w;
            this.h = h;
        }

        function Tile(bb, scale, priority) {
            this.bb = bb;
            this.scale = scale;
            this.priority = priority;
        }

    </script>
</body>

</html>