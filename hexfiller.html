<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">

<head>
    <meta charset="utf-8" />
    <title>Filler</title>
</head>

<body>

    <script type="text/javascript">

        function loop(targetFps, fixedUpdate, render) {
            let fixedDelta = 1000 / targetFps;
            let acc = fixedDelta;
            let then = performance.now();

            function tick(now) {
                let delta = now - then;
                acc += delta;
                then = now;
                let doRender = acc >= fixedDelta;

                while (acc >= fixedDelta) {
                    acc -= fixedDelta;
                    fixedUpdate(fixedDelta);
                }

                if (doRender)
                    render(delta);

                requestAnimationFrame(tick);
            }

            tick(then);
        }
    </script>

    <script type="text/javascript">

        // canvas w/ hex
        function fullscreenCanvas() {
            let [can, ctx] = makeCanvas(window.innerWidth, window.innerHeight, false)
            ctx.translate(can.width / 2, can.height / 2);

            document.body.appendChild(can);
            document.body.style.overflow = "hidden";
            document.body.style.margin = "0";
            document.body.style.padding = "0";

            return ctx;
        }

        function makeCanvas(width, height, alpha) {

            let can = document.createElement('canvas');
            let ctx = can.getContext('2d', { alpha });

            ctx.canvas.width = width;
            ctx.canvas.height = height;
            ctx.canvas.style.display = 'block';

            ctx.clear = function () {
                ctx.clearRect(-ctx.canvas.width / 2, -ctx.canvas.height / 2, ctx.canvas.width, ctx.canvas.height);
            };

            let q = 1 / Math.sqrt(3);

            ctx.getHexPath = function (h) {
                let dx = q * h / 2;
                let dy = h / 2;

                return [2 * dx, 0
                    , dx, -dy
                    , -dx, -dy
                    , -2 * dx, 0
                    , -dx, dy
                    , dx, dy];
            }

            ctx.makePath = function (vertices) {
                this.beginPath();
                this.moveTo(vertices[0], vertices[1]);
                for (let i = 2; i < vertices.length; i += 2) {
                    this.lineTo(vertices[i], vertices[i + 1]);
                }
                this.closePath();
            }

            ctx.pathHex = function (h) {
                this.makePath(this.getHexPath(h));
            };

            ctx.fillHex = function (x, y, h) {
                this.save();
                this.translate(x, y);
                this.pathHex(h);
                this.fill();
                this.restore();
            };

            ctx.strokeHex = function (x, y, a) {
                this.save();
                this.translate(x, y);
                this.pathHex(a);
                this.stroke();
                this.restore();
            };

            return [can, ctx];
        }
    </script>

    <script type="text/javascript">
        // Field 
        (function (global) {
            "use strict";

            function Field(mi, mj, makeCell) {
                let body = [];

                for (let i = 0; i < mi; ++i) {
                    let row = [];
                    for (let j = 0; j < mj; ++j) {
                        row.push(makeCell(i, j));
                    }
                    body.push(row);
                }

                this.body = body;
            }

            Field.prototype.forEach = function (processCell) {
                for (let i = 0; i < this.body.length; ++i)
                    for (let j = 0; j < this.body[i].length; ++j)
                        if (this.body[i][j] !== null)
                            processCell(i, j, this.body[i][j]);
            }

            Field.prototype.evolve = function (processCell) {
                let body = [];

                for (let i = 0; i < this.body.length; ++i) {
                    let row = [];

                    for (let j = 0; j < this.body[i].length; ++j) {
                        let cell = this.body[i][j];
                        row.push(cell === null ? null : processCell(i, j, cell));
                    }

                    body.push(row);
                }

                this.body = body;
            }

            global.Field = Field;

        }(this));

    </script>

    <script type="text/javascript">

        // SuperCell
        (function (global) {
            "use strict";

            function SuperCell(rank) {
                if (rank < 1)
                    throw new Error('SuperCell rank cannot be less than 1');

                this.rank = rank;
            }

            function getDimension() {
                return 4 * this.rank + 1;
            }

            Object.defineProperty(SuperCell.prototype, 'width', { get: getDimension });
            Object.defineProperty(SuperCell.prototype, 'height', { get: getDimension });

            SuperCell.prototype.contains = function (i, j) {
                let r = this.rank;

                let h2 = r * 2;

                let a = 8 * r + 1;
                let b = 6 * r + 1;
                let c = 4 * r - 1;

                return j * 2 - i + h2 - (a + b) / 2 <= 0
                    && j * 2 - i + h2 - (a - b) / 2 >= 0
                    && j * 1 / 2 - i + h2 - (c + b) / 4 <= 0
                    && j * 1 / 2 - i + h2 - (c - b) / 4 >= 0
                    && j * -1 - i + h2 + (c + b) / 2 >= 0
                    && j * -1 - i + h2 + (c - b) / 2 <= 0;
            }

            global.SuperCell = SuperCell;
        }(this));

    </script>

    <script type="text/javascript">

        let sq32 = Math.sqrt(3) / 2;
        let tau = 2 * Math.PI;

        function hexToPix(i, j, h) {
            return [
                h * (j) * sq32,
                -h * (i - j / 2) + h / 4
            ];
        }

        function rnd() {
            switch (arguments.length) {

                case 1:
                    if (arguments[0] instanceof Array)
                        return arguments[0][Math.floor(Math.random() * arguments[0].length)];
                    else return arguments[0] * Math.random();
                case 2:
                    return arguments[0] + Math.random() * (arguments[1] - arguments[0]);
                case 0:
                default:
                    return Math.random();
            }
        }

        function getGenerator(sc, colors) {
            return function (i, j) {
                return sc.contains(i, j)
                    ? {
                        current: rnd(colors.length) | 0,
                        next: null
                    }
                    : null;
            }
        }

        let colors = ["rgb(255,40,20)", "rgb(153,153,153)", "rgb(238,139,0)", "rgb(139,167,0)", "rgb(0,185,169)", "rgb(94,121,255)", "rgb(207,0,248)"];
        let ctx = fullscreenCanvas();
        let s = 35;
        let isSimple = true;

        let prerendered = (() => {

            let outer = ctx.getHexPath(.98 * s);
            let inner = ctx.getHexPath(.85 * s);

            let extent = outer.reduce((extent, coord, i) => {

                let k = i % 2;
                extent[k] = Math.min(extent[k], coord)
                extent[k + 2] = Math.max(extent[k + 2], coord)
                return extent;

            }, [0, 0, 0, 0]);

            let w = Math.ceil(extent[2]) - Math.floor(extent[0]);
            let h = Math.ceil(extent[3]) - Math.floor(extent[1]);

            return colors.map(color => {
                let [can, c] = makeCanvas(w, h, true);
                c.translate(w / 2, h / 2);
                renderHex(c, s, color);
                return can;
            })
        })();

        let sc = new SuperCell(7);
        let fld = new Field(sc.width, sc.height, getGenerator(sc, colors));
        let ijorigin = sc.rank * 2;


        function renderHex(ctx, s, color) {
            ctx.save();

            let outer = ctx.getHexPath(.98 * s);
            let inner = ctx.getHexPath(.85 * s);

            ctx.fillStyle = color;
            ctx.makePath(outer);
            ctx.fill();

            ctx.restore();

            if (isSimple) return;

            ctx.globalCompositeOperation = 'screen';

            let grad = ctx.createLinearGradient(0, s / 2, 0, -s / 2);
            grad.addColorStop(1, 'rgba(255,255,255, .3)');
            grad.addColorStop(.8, 'rgba(255,255,255,0)');
            grad.addColorStop(.6, 'rgba(255,255,255,0)');
            grad.addColorStop(.1, 'rgba(255,255,255, .4)');
            grad.addColorStop(0, 'rgba(255,255,255,.2)');

            ctx.fillStyle = grad;
            ctx.fill();

            grad = ctx.createLinearGradient(0, .7 * s / 2, 0, .7 * -s / 2);
            grad.addColorStop(1, 'rgba(255,255,255, .4)');
            grad.addColorStop(0, 'rgba(255,255,255,0)');

            ctx.fillStyle = grad;
            ctx.makePath(inner);
            ctx.fill();

            let l = outer.length;
            let mode = ['screen', 'screen', 'screen', 'screen', 'multiply', 'multiply'];
            let tints = [
                'rgba(255, 255, 255, .0)', 'rgba(255, 255, 255, .0)',
                'rgba(255, 255, 255, .2)', 'rgba(255, 255, 255, .4)',
                'rgba(255, 255, 255, .2)', 'rgba(255, 255, 255, .1)',
                'rgba(255, 255, 255, .0)', 'rgba(255, 255, 255, .0)',
                'rgba(0, 0, 0, .1)', 'rgba(0, 0, 0, .3)',
                'rgba(0, 0, 0, .3)', 'rgba(0, 0, 0, .2)'
            ];

            for (let i = 0; i < l; i += 2) {

                grad = ctx.createLinearGradient(outer[i], outer[i + 1], inner[(i + 3) % l], inner[(i + 4) % l]);

                grad.addColorStop(0, tints[i]);
                grad.addColorStop(1, tints[i + 1]);

                ctx.fillStyle = grad;

                ctx.makePath([
                    outer[i], outer[i + 1], outer[(i + 2) % l], outer[(i + 3) % l],
                    inner[(i + 2) % l], inner[(i + 3) % l], inner[i], inner[i + 1]
                ]);

                ctx.globalCompositeOperation = mode[i / 2];
                ctx.fill();
            }

            ctx.restore();
        }

        function render(i, j, cell) {
            let s = 35;
            let pos = hexToPix(i - ijorigin, j - ijorigin, s);
            let x = pos[0], y = pos[1];

            ctx.drawImage(prerendered[cell.current], x, y);
        }

        let colorChange = new Accumulator(2000);
        let phase = 0;

        function Accumulator(target) {
            this.target = target;
            this.value = 0;
        }

        Accumulator.prototype.add = function (value) {
            this.value += value;

            if (this.value > this.target) {
                this.value -= this.target;
                return true;
            }

            return false;
        }

        function MovingAverage(n) {
            this.samples = new Array(n);
            this.pointer = 0;
        }

        MovingAverage.prototype.addSample = function (sample) {
            this.samples[this.pointer++] = sample;
            if (this.pointer >= this.samples.length)
                this.pointer = 0;
        }

        MovingAverage.prototype.average = function () {
            let res = this.samples.reduce(function (sumobj, value) { return { sum: sumobj.sum + value, count: sumobj.count + 1 } }, { sum: 0, count: 0 });

            return res.sum / res.count;
        }

        let fixedFps = new MovingAverage(100);
        let updateFps = new MovingAverage(100);

        loop(60, fixedUpdate, update);

        function fixedUpdate(delta) {
            fixedFps.addSample(delta);

            let newTarget = null;

            if (colorChange.add(delta)) {
                newTarget = rnd(colors.length) | 0;
            }

            fld.evolve(function (i, j, cell) {
                if (cell.next && cell.next.in < delta)
                    cell.current = cell.next.value;

                if (newTarget) {
                    cell.next = {
                        value: newTarget,
                        in: 20 * (i + j) * rnd(.8, 1.2)
                    };
                }
                else if (cell.next) {
                    cell.next.in -= delta;
                }

                return cell;
            });
        }

        function reportfps() {
            console.log('fixed: ' + 1000 / fixedFps.average() + '; update: ' + 1000 / updateFps.average())
        }

        function update(delta) {
            updateFps.addSample(delta);

            ctx.clear();
            fld.forEach(render);
        }

    </script>

</body>

</html>