<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">

<head>
    <meta charset="utf-8" />
    <title>Digger</title>
</head>

<body>
    <script name="canvas" type="text/javascript">
        // canvas w/ hex
        function fullscreenCanvas(width, height, alpha) {
            let [can, ctx] = makeCanvas(window.innerWidth, window.innerHeight, width, height, alpha)

            document.body.appendChild(can);
            document.body.style.overflow = "hidden";
            document.body.style.margin = "0";
            document.body.style.padding = "0";

            return ctx;
        }

        function makeCanvas(displayWidth, displayHeight, width, height, alpha) {

            let can = document.createElement('canvas');
            let ctx = can.getContext('2d', { alpha, antialias: false });
            ctx.canvas.style.position = 'absolute';
            ctx.canvas.style.width = displayWidth + 'px';
            ctx.canvas.style.height = displayHeight + 'px';
            ctx.canvas.width = width;
            ctx.canvas.height = height;
            ctx.canvas.style.display = 'block';

            return [can, ctx];
        }

        function canvas(width, heigh) {
            let canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            return canvas;
        }

        CanvasRenderingContext2D.prototype.fillCircle = function (x, y, r) {
            this.beginPath();

            this.arc(x, y, r, 0, Math.PI * 2);

            this.closePath();
            this.fill();
        }
    </script>

    <script name="loop" type="text/javascript">
        function loop(targetFps, fixedUpdate, render) {
            const maxReps = 20;
            let fixedDelta = 1000 / targetFps;
            let acc = fixedDelta;
            let then = performance.now();

            function tick(now) {
                let delta = now - then;
                acc += delta;
                then = now;
                let doRender = false;
                let reps = 0;

                while (acc >= fixedDelta && ++reps < maxReps) {
                    acc -= fixedDelta;
                    doRender ||= fixedUpdate(fixedDelta);
                }

                if (reps == maxReps) acc = 0;

                if (doRender)
                    render(delta);

                requestAnimationFrame(tick);
            }

            tick(then);
        }
    </script>

    <script name="rect" type="text/javascript">
        class Rect {
            constructor(x, y, w, h) {
                this.x = x;
                this.y = y;
                this.w = w;
                this.h = h;
            }
        }
    </script>

    <script type="text/javascript">
        // geodes fall and break producing gems
        // there are tunnels

        const width = 320;
        const height = 240;

        let x = 0, y = 0;
        let cw = width, ch = height;

        let screenAspect = window.innerWidth / window.innerHeight;
        let viewAspect = width / height;

        if (viewAspect > screenAspect) {
            ch = (width / screenAspect) | 0
            y = ((ch - height) / 2) | 0
        }
        else {
            cw = (height * screenAspect) | 0
            x = ((cw - width) / 2) | 0
        }

        const view = new Rect(x, y, width, height);
        const can = new Rect(0, 0, cw, ch);

        const bg = fullscreenCanvas(cw, ch, false);
        const fg = fullscreenCanvas(cw, ch, true);

        bg.imageSmoothingEnabled = false;
        fg.imageSmoothingEnabled = false;

        const n = 10;
        const m = 13;

        const TILE_SOLID = 0;
        const TILE_GEODE = 1;
        const TILE_VOID = 2;
        const TILE_NUGGET = 3;
        const TILE_GEM = 4;

        const probabilities = [
            [20, TILE_SOLID],
            [2, TILE_GEODE],
            [1, TILE_VOID],
            [3, TILE_NUGGET]
        ];

        let totalProb = probabilities.reduce((sum, [prob, _]) => sum + prob, 0);
        probabilities.forEach(pair => pair[0] /= totalProb);

        const map = array(n, m, (i, j) => {
            return pick(probabilities)
        });

        for (let i = 0; i < n - 1; ++i)
            for (let j = 0; j < m; ++j) {
                let c = map[i][j];
                let b = map[i + 1][j];

                if (b == TILE_VOID && c != TILE_SOLID && c != TILE_VOID) map[i + 1][j] = TILE_SOLID
            }

        //renderMap(bg, map);

        function edgeIndex(td, lr, v, h, d) {
            // the sprite for the corner of an empty cell is calculated based on:
            // - is the corner top (1) or bottom (0)
            // - is the corner left (1) or right (0)
            // - is the vertical neighbour solid (1) or empty (0)
            // - is the horizonal neighbour solid (1) or empty (0)
            // - is the diagonal neighbour solid (1) or empty (0)

            return ((((!!td) << 1
                | (!!lr)) << 1
                | (!!v)) << 1
                | (!!h)) << 1
                | (!!d);
        }

        let bgColors = ['#202B39', '#1C3645', '#215A69'].map(hex2rgb);
        let geodeColors = ['#502C8D', '#504CaD', '#3DD9D8'].map(hex2rgb);
        let nuggetColors = ['#A67C00', '#FFBF00', '#FFE878'].map(hex2rgb);
        let gemColors = ['#3DD9D8', '#3D7988', '#AFF8CA'].map(hex2rgb);

        console.log(nuggetColors)

        fetchImage(getSprites()).then(data => {
            let s = 10;
            let sprites = [];

            sprites[edgeIndex(1, 1, 1, 1, 1)] =
                sprites[edgeIndex(1, 1, 1, 1, 0)] = new Sprite(data, 0, s, s, s);
            sprites[edgeIndex(1, 1, 1, 0, 1)] =
                sprites[edgeIndex(1, 0, 1, 0, 1)] = new Sprite(data, s, s, s, s);
            sprites[edgeIndex(1, 0, 1, 1, 1)] =
                sprites[edgeIndex(1, 0, 1, 1, 0)] = new Sprite(data, 2 * s, s, s, s);

            sprites[edgeIndex(1, 1, 0, 1, 1)] =
                sprites[edgeIndex(0, 1, 0, 1, 1)] = new Sprite(data, 0, 2 * s, s, s);
            sprites[edgeIndex(1, 0, 0, 1, 1)] =
                sprites[edgeIndex(0, 0, 0, 1, 1)] = new Sprite(data, 2 * s, 2 * s, s, s);

            sprites[edgeIndex(0, 1, 1, 1, 1)] =
                sprites[edgeIndex(0, 1, 1, 1, 0)] = new Sprite(data, 0, 3 * s, s, s);
            sprites[edgeIndex(0, 1, 1, 0, 1)] =
                sprites[edgeIndex(0, 0, 1, 0, 1)] = new Sprite(data, s, 3 * s, s, s);
            sprites[edgeIndex(0, 0, 1, 1, 1)] =
                sprites[edgeIndex(0, 0, 1, 1, 0)] = new Sprite(data, 2 * s, 3 * s, s, s);

            sprites[edgeIndex(0, 1, 1, 0, 0)] = new Sprite(data, 4 * s, 0, s, s);
            sprites[edgeIndex(0, 0, 1, 0, 0)] = new Sprite(data, 5 * s, 0, s, s);
            sprites[edgeIndex(1, 1, 1, 0, 0)] = new Sprite(data, 4 * s, s, s, s);
            sprites[edgeIndex(1, 0, 1, 0, 0)] = new Sprite(data, 5 * s, s, s, s);

            sprites[edgeIndex(1, 0, 0, 1, 0)] = new Sprite(data, 3 * s, 2 * s, s, s);
            sprites[edgeIndex(1, 1, 0, 1, 0)] = new Sprite(data, 4 * s, 2 * s, s, s);
            sprites[edgeIndex(0, 0, 0, 1, 0)] = new Sprite(data, 3 * s, 3 * s, s, s);
            sprites[edgeIndex(0, 1, 0, 1, 0)] = new Sprite(data, 4 * s, 3 * s, s, s);

            let textures = [
                new Sprite(data, 5 * s, 2 * s, 2 * s, 2 * s, bgColors.map(shuffle)),
                new Sprite(data, 7 * s, 2 * s, 2 * s, 2 * s, bgColors.map(shuffle)),
                new Sprite(data, 9 * s, 2 * s, 2 * s, 2 * s, bgColors.map(shuffle)),
                new Sprite(data, 11 * s, 2 * s, 2 * s, 2 * s, bgColors.map(shuffle))
            ];

            let pups = [
                new Sprite(data, 7 * s, 0, 2 * s, 2 * s, geodeColors),
                new Sprite(data, 9 * s, 0, 2 * s, 2 * s, nuggetColors),
                new Sprite(data, 11 * s, 0, 2 * s, 2 * s, gemColors)
            ]

            console.log(pups[0].imgdata)

            let s2 = 3 * s;
            let x = s;
            let y = s;
            for (let t = 0; t < 2; ++t)
                for (let l = 0; l < 2; ++l)
                    for (let v = 0; v < 2; ++v)
                        for (let h = 0; h < 2; ++h)
                            for (let d = 0; d < 2; ++d)
                                if (v + h > 0) {
                                    fg.fillStyle = 'green'
                                    fg.fillRect(x - 1, y - 1, s + 2, s + 2)

                                    let ww = 3;

                                    let dx = (!!l) ? -ww : s;
                                    let dy = (!!t) ? -ww : s;

                                    if (!!v) fg.fillRect(x, y + dy, s, ww);
                                    if (!!h) fg.fillRect(x + dx, y, ww, s);

                                    if (!!d) fg.fillRect(x + dx, y + dy, ww, ww)

                                    fg.fillStyle = 'yellow'
                                    fg.fillRect(x + ((!!l) ? -1 : 1), y + ((!!t) ? -1 : 1), s, s)

                                    console.log(t, l, v, h, d)


                                    sprites[edgeIndex(t, l, v, h, d)].draw(fg, x, y)

                                    if ((x += s2) > 500) {
                                        x = s; y += s2
                                    }
                                }

            x = s; y += s2

            for (let txt of textures) {
                txt.draw(fg, x, y)
                txt.draw(fg, x + 2 * s, y)
                txt.draw(fg, x, y + 2 * s)
                txt.draw(fg, x + 2 * s, y + 2 * s)
                x += 2 * s2
            }

            x = s; y += s2

            for (let txt of pups) {
                txt.draw(fg, x, y)
                x += 2 * s2
            }
        });

        loop(update, render);

        function update() {

        }

        function render() {

        }

        function renderMap(ctx, map) {
            let ox = 10;
            let oy = 30;
            let sx = 20;
            let sy = 20;

            for (let i = 0; i < map.length; ++i) {
                for (let j = 0; j < map[i].length; ++j) {
                    ctx.save();
                    ctx.translate(ox + sx * j, oy + sy * i);

                    switch (map[i][j]) {
                        case TILE_SOLID:
                            ctx.fillStyle = 'brown'
                            ctx.fillRect(0, 0, sx, sy)
                            break;
                        case TILE_VOID:
                            break;
                        case TILE_GEODE:
                            ctx.fillStyle = 'gray'
                            ctx.fillCircle(sx / 2, sy / 2, sx / 2)
                            break;
                        case TILE_NUGGET:
                            ctx.fillStyle = 'gold'
                            ctx.fillCircle(sx / 2, sy / 2, .6 * sx / 2)
                            break;
                    }

                    ctx.restore();
                }
            }
        }

        function array(n, m, gen) {
            let a = [];
            for (let i = 0; i < n; ++i) {
                let r = [];
                for (let j = 0; j < m; ++j) {
                    r.push(gen(i, j));
                }
                a.push(r)
            }
            return a;

        }

        function pick(scoreValueArray) {
            let t = Math.random();
            for (let [score, value] of scoreValueArray) {
                if ((t -= score) < 0) return value;
            }
        }

        function shuffle(a) {
            let b = [...a];
            b.sort(() => Math.random() - .5);
            return b;
        }

        class Sprite {

            imgdata;
            #ox = 0;
            #oy = 0;
            #w = 0;
            #h = 0;

            constructor(ctx, ox, oy, w, h, palette) {
                this.imgdata = ctx.getImageData(ox, oy, w, h);

                if (palette) this.#map(palette)

                this.#ox = ox;
                this.#oy = oy;
                this.#w = w;
                this.#h = h;
            }

            #map(palette) {
                let a = this.imgdata.data;
                let n = a.length;

                for (let i = 0; i < n; i += 4) {

                    let c = palette[1];
                    if (a[i] < 64) c = palette[0]
                    if (a[i] > 64) c = palette[2]

                    a[i + 3] = a[i] == 255 ? 0 : 255
                    a[i] = c[0];
                    a[i + 1] = c[1];
                    a[i + 2] = c[2];
                }
            }

            draw(ctx, x, y) {
                ctx.putImageData(this.imgdata, x, y);
            }
        }

        async function fetchImage(url) {
            return new Promise((resolve, reject) => {
                let img = new Image();

                img.setAttribute('crossOrigin', 'anonymous');

                img.onload = function () {
                    let can = canvas(img.width, img.height);
                    let ctx = can.getContext("2d");

                    if (ctx != null) {
                        ctx.drawImage(img, 0, 0);
                        resolve(ctx)//.getImageData(0, 0, can.width, can.height))
                    }
                    else reject("Failed to load image");
                };

                img.src = url;
            });
        }

        function hex2rgb(hex) {
            return [
                parseInt(hex.substring(1, 3), 16),
                parseInt(hex.substring(3, 5), 16),
                parseInt(hex.substring(5, 7), 16)
            ]
        }

        function getSprites() {
            return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIIAAAAoBAMAAADAqj9GAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAPUExURf///wAAAEBAQICAgMDAwGEBT6wAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAIeSURBVEjHvVYLrtsgEIT2AsxygbI5AXCCd/9LdT/g2HmQZzVSrchBlneYmd0hCf/vAvAxANKHAPQRiQh8SCIiQz4fIKA8OfRyqIlv9gzycjpRgGJQGusBEfMeAAn6iQME1Zzk5AC96fMa0Pakj+ugoBCKgNwK6yL0lOuf69vPkjUClxRib1zckFwYW4SIaCpw2CCtaFRk2ZnZEcDkMkStyE0pJPk+atRGTC9jVgZSKcvG/PC3QJSbkkCaxkfdbSKEc6/MBFMf5Yu9nVEA5LHudPFw6SxpfSu2VC7G7Rdll51uIMjO5A2QnXmOZi7o1p47CLpzmYrm0986ZuEegpTx91BIA/AdYTfp8U2qbnF4ey0QPA4+h13cQu/domHmF4ykzhm80vNZGfduEIwsPlaZIzTF0ZDSFsEnyu+yuUFoIfAgIVJylohWkESCjIjcrypGrZ8kDIPAEKCjVKTEUBQSfl/1wlWw2yBidDcyGCplWIFiCIVWPsSRvY2TcAEnFSuErZOzGz84OTgsnESttnm+IIQNwspJSTOpP7UeapYIceukLkiRgKMdq5mcPqycNBD2iSr0DzM5+fNZxaIXnouFk3xtw87J+Ork19NJOfJtqOqdXmycdDfyLhc/Oymqans24kGbbKatk5ou6IF/ykXUOCWLVMKZw2ompZQ0mnRWAfuNs59qnBFWMyl8tP7ljHrpTZin3NrJWov9pZoX8BeC3W8NFYaD7gAAAABJRU5ErkJggg==';
        }
    </script>
</body>

</html>