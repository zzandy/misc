<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">

<head>
    <meta charset="utf-8" />
    <title>Sim</title>
    <script src="lightue.min.js"></script>
    <style>
        html,
        body {
            line-height: 1.5rem;
        }

        .line>div {
            display: inline-block;
        }

        .line *:not(:first-child) {
            margin: 0 .2rem;
        }

        .group>button {
            border-radius: 0;
            border: outset silver;
            border-width: 1px 0 1px 1px;
            margin: 1px 0;
        }

        .group>button:first-child {
            border-start-start-radius: .2em;
            border-end-start-radius: .2em;
        }

        .group>button:last-child {
            border-start-end-radius: .2em;
            border-end-end-radius: .2em;
            border-width: 1px;
        }

        .notes>* {
            animation: fade 2s;
        }

        @keyframes fade {
            0% {
                display: block;
                opacity: 100%;
            }

            60% {
                opacity: 100%;
            }

            100% {
                opacity: 0;
                display: none;
            }
        }
    </style>
</head>

<body>

    <canvas id="graph" width="300" height="130">

    </canvas>

    <script name="loop" type="text/javascript">
        function loop(targetFps, fixedUpdate, render) {
            let fixedDelta = 1000 / targetFps;
            let acc = fixedDelta;
            let then = performance.now();

            function tick(now) {
                let delta = now - then;
                acc += delta;
                then = now;
                let reps = 0;

                while (acc >= fixedDelta && ++reps < 20) {
                    acc -= fixedDelta;
                    fixedUpdate(fixedDelta);
                }

                if (reps == 20) acc = 0;

                render(delta);

                requestAnimationFrame(tick);
            }

            tick(then);
        }
    </script>

    <script type="text/javascript">
        (() => {

            // todo/ideas
            //   - lifetime stats
            //   - live stats display
            //   - achievements 

            const { useState, button, div, span } = Lightue;
            const pow = Math.pow;

            let production = 0;
            let income = 0;
            let cleanupRate = 0;
            let samplesUpdated = false;
            const samples = [[], [], [], []]; // production, income, cleanup, waste
            let manualProdSpot = 0;
            const manualProdSamples = []; for (let i = 0; i < 60; ++i) manualProdSamples.push(0);
            let manualProdCursor = 0
            const numSamples = 300;
            let record = 0;

            let cleanupSpot = 0;
            let cleanupCursor = 0;
            const cleanupSamples = []; for (let i = 0; i < 60; ++i) cleanupSamples.push(0);

            const can = document.getElementById('graph');
            const ctx = can.getContext('2d');

            const state = useState({
                inventory: 0,
                balance: 0,
                price: 1,
                numAgents: 0,
                agentLevel: 1,
                manualRate: 1,
                features: [],
                interestLevel: 0,
                autosellLevel: 0,
                autosellRate: 0,
                autosellRateAgg: 0,
                notes: [],

                storage: 1000,
                storageLevel: 1,
                waste: 0,
                cleanup: 0
            });

            function storageChange(n) {
                return 1000 * Math.pow(10, (n / 9) | 0);
            }

            const autoCount = upgradable(dt => state.numAgents += dt, t => t, t => 10 * pow(t, 1.3), () => 'Add agent');
            const autoRate = upgradable(dt => state.agentLevel += dt, t => 1 + (t - 1) * .05, t => 120 * pow(1.1, t), () => 'Upgrade autoprodution rate');
            const interest = upgradable(dt => state.interestLevel += dt, t => t * 0.2, t => 1000 * pow(t, 1.3), (value, next) => `${nice(next)}%`);
            const autosell = upgradable(dt => state.autosellLevel += dt, t => !!t * pow(10, t), t => !!t * 10 * pow(10, t) / 5, (value, next) => `${next}`);
            const autosellRate = upgradable(dt => state.autosellRate += dt, t => 20 - t, t => t < 20 ? 1000 * pow(t, 1.4) : 1e20, (value, next) => `${next} seconds`);
            const storage = upgradable(dt => { if (dt > 0) state.storage += storageChange(state.storageLevel); return state.storageLevel += dt }, storageChange, t => storageChange(t - 1), (value, next) => `Add ${value} to storage capacity`);

            const noteAutosell = note();
            const noteInterest = note();
            const noteRecord = note();

            function sell(n) {
                if (state.inventory >= n) {
                    state.inventory -= n;

                    let sale = n * state.price
                    state.balance += sale;

                    income += sale;

                    return true;
                }

                return false;
            }

            function produce(n) {
                let spare = state.storage - state.inventory;
                let cleanup = spare > 0 ? Math.min(state.waste / 2, n / 3) : 0;
                let produced = Math.min(n - cleanup, spare);
                let wasted = n - cleanup - produced;

                production += produced;
                cleanupRate += cleanup;
                cleanupSpot += cleanup;

                state.waste += wasted - cleanup;
                state.inventory += produced;
            }

            loop(60, delta => {
                const produced = delta * state.numAgents * autoRate.getValue() / 1000;

                produce(produced);

                samplesUpdated = true;

                cleanupSamples[(cleanupCursor++) % 60] = cleanupSpot;
                manualProdSamples[(manualProdCursor++) % 60] = manualProdSpot;
                state.manualProd = manualProdSamples.reduce((a, b) => a + b);
                state.cleanup = cleanupSamples.reduce((a, b) => a + b);

                if (state.manualProd > 10 && state.manualProd > record) {
                    record = state.manualProd;
                    noteRecord.show('New production record!!');
                }

                cleanupSpot = 0;
                manualProdSpot = 0;

                if (state.autosellLevel > 0) {
                    if ((state.autosellRateAgg += delta / 1000) > autosellRate.getValue()) {
                        state.autosellRateAgg -= autosellRate.getValue();
                        const sellAmount = autosell.getValue();
                        if (sell(sellAmount)) {
                            noteAutosell.show('Autosold ' + sellAmount + ' items');
                        }
                    }
                }
            }, () => { });

            // stats loop
            loop(2, () => {
                if (samplesUpdated) {
                    const newSamples = [production, income, cleanupRate, state.waste];
                    for (let i = 0; i < samples.length; ++i)
                        if (samples[i].push(newSamples[i]) >= numSamples)
                            samples[i].shift();

                    production = 0;
                    income = 0;
                    cleanupRate = 0;
                    samplesUpdated = false;
                }
            }, () => {
                const { width, height } = can;
                const colors = ['black', 'red', 'magenta', 'purple'];
                const line = {};
                const bars = {};
                const styles = [line, bars, line, line];

                const prodScale = { min: Infinity, max: -Infinity }
                const scales = [prodScale, { min: Infinity, max: -Infinity }, prodScale, { min: Infinity, max: -Infinity }];


                for (let l = 0; l < samples.length; ++l) {
                    const scale = scales[l];
                    for (const sample of samples[l]) {
                        scale.min = Math.min(scale.min, sample);
                        scale.max = Math.max(scale.max, sample);
                    }

                    if (scale.max < 10) scale.max = 10;
                }

                ctx.clearRect(0, 0, width, height);

                for (let l = 0; l < samples.length; ++l) {
                    ctx.strokeStyle = colors[l % colors.length];
                    const style = styles[l % styles.length];
                    const { min, max } = scales[l % scales.length]

                    ctx.beginPath();
                    for (let i = 0; i < numSamples; ++i) {

                        if (samples[l][i] === undefined) break;

                        const x = i * width / numSamples;
                        const y = height - (samples[l][i]) / max * height;

                        if (style == bars) {
                            ctx.strokeRect(x, y, 0, height)
                        }
                        else {
                            if (i == 0) ctx.moveTo(x, y)
                            else ctx.lineTo(x, y);
                        }
                    }

                    ctx.stroke();
                }
            });

            // interest loop
            loop(1 / 10, () => {
                const int = interest.getValue() / 100 * state.balance

                state.balance += int;
                income += int;

                if (int > 0) {
                    noteInterest.show('Interest ' + (int > 5 ? Math.round(int) : int.toFixed(3)));
                }
            }, () => { });

            let t = 0;

            Lightue({
                balance: () => 'Balance: ' + nice(state.balance),
                inventory: () => 'In stock: ' + (state.inventory | 0) + ' / ' + state.storage,
                wast: {
                    $$: () => `Waste: ${state.waste | 0}${nice(state.cleanup) ? `; ${nice(state.cleanup)} production goes towards cleanup` : ''}`,
                    $if: () => state.waste > 0
                },
                numAgents: () => 'Automakers: ' + state.numAgents + '@' + nice(autoRate.getValue()) + ' (' + nice(state.numAgents * autoRate.getValue()) + ' per second)',
                intr: {
                    $$: () => 'Interest: ' + nice(interest.getValue()) + '%',
                    $if: () => state.interestLevel > 0
                },

                make: [
                    btn(() => `Make ${nice(state.manualRate)
                        }`, () => {
                            manualProdSpot += state.manualRate;
                            produce(state.manualRate);
                        }),
                    span({
                        _style: 'padding-left: .5em',
                        $if: () => state.manualProd > 0,
                        $$: () => state.manualProd + ' per second'
                    })
                ],

                sell: div.group([
                    btn("Sell one", () => sell(1), () => state.inventory >= 1, () => !has('Sell 1000s')),
                    btn("Sell ten", () => sell(10), () => state.inventory >= 10, () => has('Sell 10s') && !has('Sell 10K')),
                    btn("Sell hundred", () => sell(100), () => state.inventory >= 100, () => has('Sell 100s') && !has('Sell 100K')),
                    btn("Sell thousand", () => sell(1000), () => state.inventory >= 1000, () => has('Sell 1000s')),
                    btn("Sell 10K", () => sell(10000), () => state.inventory >= 10000, () => has('Sell 10K')),
                    btn("Sell 100K", () => sell(100000), () => state.inventory >= 100000, () => has('Sell 100K')),
                    btn("Sell a million", () => sell(1000000), () => state.inventory >= 1000000, () => has('Sell 1M')),
                ]),

                man: upgrade('Increase manual rate', () => round(state.manualRate * 100 * 1.1), () => ++state.manualRate),
                str: upgradeObj(storage),
                aut: div.group([
                    upgradeObj(autoCount),
                    upgradeObj(autoRate),
                ]),

                selss: div.group([
                    feat('Sell 10s', 20),
                    feat('Sell 100s', 250),
                    feat('Sell 1000s', 3000, () => has('Sell 10s')),
                    feat('Sell 10K', 40000, () => has('Sell 100s')),
                    feat('Sell 100K', 500000, () => has('Sell 1000s')),
                    feat('Sell 1M', 7000000, () => has('Sell 10K'))
                ]),

                int: div.line([() => `Interest ${nice(interest.getValue())}% `, upgradeObj(interest)]),

                autosell: div.line([
                    () => `Autosell ${autosell.getValue()} `,
                    upgradeObj(autosell),
                    () => `every ${autosellRate.getValue()} seconds`,
                    upgradeObj(autosellRate),
                ]),

                notes: state.notes
            });

            function upgradeObj(obj) {
                return upgrade(obj.getLabel, obj.getUpgradePrice, obj.upgrade);
            }

            function upgradable(getSetTier, tierToValue, tierToPrice, labelFn) {
                function getValue() {
                    return tierToValue(getSetTier(0));
                }

                function getNextValue() {
                    return tierToValue(getSetTier(0) + 1);
                }

                function getUpgradePrice() {
                    return round(tierToPrice(getSetTier(0) + 1));
                }

                function getLabel() {
                    return labelFn(getValue(), getNextValue())
                }

                function upgrade() {
                    getSetTier(1);
                }

                return {
                    upgrade,
                    getValue,
                    getNextValue,
                    getUpgradePrice,
                    getLabel
                }
            }

            function note() {

                let current = null;
                let timer = null;

                function show(note) {

                    note = { note }

                    if (current) {
                        const id = state.notes.indexOf(current);
                        state.notes.splice(id, 1, note);

                        current = state.notes[id];
                        clearTimeout(timer);
                    }
                    else {
                        const id = state.notes.push(note);
                        current = state.notes[id - 1];
                    }

                    timer = setTimeout(() => {
                        const id = state.notes.indexOf(current);
                        state.notes.splice(id, 1);
                        current = null;
                    }, 2000);
                }
                return { show }
            }

            function has(feature) {
                return state.features.includes(feature);
            }

            function feat(title, price, offerIf) {
                return btn(title + ' (' + price + ')', () => {
                    state.features.push(title);
                }, () => state.balance >= price, () => !has(title) && (!offerIf || offerIf()))
            }

            function upgrade(title, getNextPrice, onBuy) {
                return btn(() => `${typeof title === "function" ? title() : title} (${getNextPrice()})`,
                    () => {
                        state.balance -= getNextPrice();
                        onBuy();
                    },
                    () => getNextPrice() <= state.balance);
            }

            function btn(title, onclick, activeIf, showIf) {
                return button({
                    $$: title,
                    $if: () => !showIf || showIf(),
                    onclick,
                    _disabled: () => !!activeIf && !activeIf()
                })
            }

            function round(price) {
                return ((price / 10) | 0) * 10;
            }

            function nice(value) {
                return value == (value | 0)
                    ? value
                    : value.toFixed(2);
            }
        })();
    </script>
</body>

</html>