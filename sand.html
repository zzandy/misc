<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" style="background-color: white;">

<head>
    <meta charset="utf-8" />
    <title>Sand Toy</title>
</head>

<body>
    <!-- color -->
    <script type="text/javascript">

        function hcy2rgb(h, c, y) {
            // 601
            const r = .3;
            const g = .59;
            const b = .11;

            const h0 = h;
            h /= 60;

            const k = (1 - Math.abs((h % 2) - 1));

            const K = h < 1 ? r + k * g
                : h < 2 ? g + k * r
                    : h < 3 ? g + k * b
                        : h < 4 ? b + k * g
                            : h < 5 ? b + k * r
                                : r + k * b;

            let cmax = 1;

            if (y <= 0 || y >= 1) cmax = 0;
            else cmax *= K < y ? (y - 1) / (K - 1) : K > y ? y / K : 1;
            c = Math.min(c, cmax);

            const x = c * k;
            const rgb = h < 1 ? [c, x, 0]
                : h < 2 ? [x, c, 0]
                    : h < 3 ? [0, c, x]
                        : h < 4 ? [0, x, c]
                            : h < 5 ? [x, 0, c]
                                : [c, 0, x];

            const m = y - (r * rgb[0] + g * rgb[1] + b * rgb[2]);

            const rgbdata = [rgb[0] + m, rgb[1] + m, rgb[2] + m];
            return [(rgbdata[0] * 255) | 0, (rgbdata[1] * 255) | 0, (rgbdata[2] * 255) | 0, 255];

        }

        function stringColor(tuple) {
            return `rgb(${tuple[0]}, ${tuple[1]}, ${tuple[2]})`;
        }

    </script>
    <script type="text/javascript">
        function addCanvas(w, h, dontAdd) {
            const canvas = document.createElement('canvas');

            canvas.width = w;
            canvas.height = h;

            if (!dontAdd)
                document.body.appendChild(canvas);

            return canvas.getContext('2d', { alpha: false });
        }

        function loop(fps, init, update, render) {

            let targetDelay = 1000 / fps;
            let world = init();

            let time = targetDelay + 1;

            let doRender = true;

            let then = Date.now();

            window.requestAnimationFrame(frame);

            function frame() {
                let now = Date.now();
                time += now - then;
                then = now;

                let numLoops = 0;

                while (time > targetDelay) {
                    time -= targetDelay;
                    world = update(world);
                    doRender = true;

                    if (++numLoops > 100) {
                        console.log('overload')
                        time = 0;
                        break;
                    }
                }


                if (doRender) {
                    doRender = false;
                    render(world);
                }

                window.requestAnimationFrame(frame);
            }
        }
    </script>

    <script type="text/javascript">

        class Button {
            static n = 0;
            static size = 32;

            constructor(title, fillStyle, generator) {
                this.title = title;
                this.fillStyle = fillStyle;
                this.generator = generator;

                this.x = 1.3 * Button.n * Button.size + Button.size / 2;
                this.y = Button.size / 2;

                this.w = this.h = Button.size;

                ++Button.n;
            }

            isOver(x, y) {
                return this.x <= x && this.x + this.w >= x && this.y <= y && this.y + this.h >= y
            }
        }

        class Pixel {
            static air = Symbol('air');
            static sand = Symbol('sand');
            static water = Symbol('water');
            static oil = Symbol('oil');
            static acid = Symbol('acid');
            static fire = Symbol('fire');
            static wood = Symbol('wood');
            static steam = Symbol('steam');
            static stone = Symbol('stone');

            constructor(type, tick) {
                this.type = type || Pixel.air;
                this.color = Pixel.getColor(this.type, tick);
                this.vetor = 0;
                this.decay = this.type == Pixel.steam ? (450 + 100 * Math.random()) : -1;
            }

            static getColor(type, tick) {
                var seed = Math.random();
                switch (type) {
                    case Pixel.wood:
                        return [0x99 + 10 - 20 * seed, 0x33 + 10 - 20 * seed, 0x33 + 10 - 20 * seed, 255];
                    case Pixel.fire:
                        return fireColor(true);
                    case Pixel.oil:
                        return oilColor(true);
                    case Pixel.water:
                        return waterColor(true);
                    case Pixel.acid:
                        return [0xdc + 10 - 20 * seed, 0xff - 10 * seed, 0x20 + 10 * seed, 255];
                    case Pixel.steam:
                        return [0x99 + 10 - 20 * seed, 0x99 + 20 - 40 * seed, 0x99 + 20 - 40 * seed, 255];
                    case Pixel.sand:
                        return sandColor(tick, true);
                    case Pixel.stone:
                        return hcy2rgb(70, .1, rnd(.65, .75))
                    default:
                        const k = 0;
                        return [k, k, k, 0];
                }
            }
        }

        loop(100, init, update, render);

        function init() {
            const [w, h] = [window.innerWidth, window.innerHeight];
            const ctx = addCanvas(w, h);

            ctx.canvas.style.position = 'absolute';
            ctx.canvas.style.top = '0';
            ctx.canvas.style.left = '0';

            ctx.imageSmoothingEnabled = false;

            const k = 6;
            const [wid, hei] = [w / k | 0, h / k | 0];
            const buf = addCanvas(wid, hei, true);
            const img = buf.getImageData(0, 0, wid, hei);

            const data = [];
            const next = [];

            for (let i = 0; i < wid * hei; ++i) data.push(new Pixel());

            const buttons = [
                new Button('sand', '#f7e98e', Pixel.sand),
                new Button('fire', stringColor(fireColor()), Pixel.fire),
                new Button('oil', stringColor(oilColor()), Pixel.oil),
                new Button('water', stringColor(waterColor()), Pixel.water),
                new Button('steam', '#999999', Pixel.steam),
                new Button('acid', '#ccff00', Pixel.acid),
                new Button('wood', '#993333', Pixel.wood),
                new Button('air', 'black', Pixel.air),
                new Button('stone', 'silver', Pixel.stone)
            ];

            const counters = buttons.reduce((obj, btn) => { obj[btn.generator] = 0; return obj }, {});

            const mouse = { isDown: false, x: 0, y: 0 }
            const world = { tick: 0, data, ctx, buf, img, renderWidth: w, renderHeight: h, simulationWidth: wid, simulationHeight: hei, buttons, activeButton: 0, mouse, counters };

            let isMouseDown = false;

            ctx.canvas.addEventListener('click', e => {
                for (let i in buttons) {
                    let button = buttons[i];
                    if (i != world.activeButton && button.isOver(e.clientX, e.clientY)) {
                        world.activeButton = i;
                        return;
                    }
                }
            });

            ctx.canvas.addEventListener('mousedown', e => {
                for (const button of buttons)
                    if (button.isOver(e.clientX, e.clientY)) return;
                mouse.isDown = true;
            });

            ctx.canvas.addEventListener('mouseup', e => {
                mouse.isDown = false;
            });

            ctx.canvas.addEventListener('mouseenter', e => {
                if (mouse.isDown && e.buttons != 1)
                    mouse.isDown = false;
            });

            ctx.canvas.addEventListener('mousemove', e => {
                mouse.x = e.clientX / k | 0;
                mouse.y = e.clientY / k | 0;
            });

            return world;
        }

        function displaces(type1, type2) {

            if (type1 == type2) return false;

            return type2 == Pixel.air || type2 == Pixel.steam
                || type1 == Pixel.sand && (type2 == Pixel.fire || type2 == Pixel.water || type2 == Pixel.oil || type2 == Pixel.acid)
                || type1 == Pixel.fire && (type2 == Pixel.water || type2 == Pixel.oil || type2 == Pixel.acid)
                || type1 == Pixel.water && (type2 == Pixel.oil || type2 == Pixel.acid)
                || type1 == Pixel.oil && type2 == Pixel.acid
        }

        function noop(type) {
            return Math.random() < (
                type == Pixel.sand ? .2
                    : type == Pixel.water ? .1
                        : -1
            );
        }

        function update(world) {
            ++world.tick;
            const { mouse, tick, simulationWidth: w, data, next, counters } = world;

            if (mouse.isDown) {
                add(data, w, mouse.x, mouse.y, world.buttons[world.activeButton].generator, counters);
            }

            const l = data.length;

            const a = Math.random() < .5 ? 1 : -1;

            let start = tick % 2 == 0 ? 0 : (l - 1);
            let step = tick % 2 == 0 ? 1 : -1;

            for (let i = start; i < l && i >= 0; i += step) {
                let x = i % w;
                let y = i / w | 0

                const pixel = data[i];

                if (pixel.type != Pixel.air && pixel.tick == tick) continue;

                const lazy = noop(pixel.type);
                let target = i;

                switch (pixel.type) {
                    case Pixel.oil:
                    case Pixel.water:
                    case Pixel.acid:
                    case Pixel.fire:
                        if (i + w < l && displaces(pixel.type, data[i + w].type)) {
                            target = i + w;
                        }
                        else if (x + a < w && x + a >= 0 && i + w + a < l && displaces(pixel.type, data[i + w + a].type)) {
                            target = i + w + a;
                        }
                        else if (x - a < w && x - a >= 0 && i + w - a < l && displaces(pixel.type, data[i + w - a].type)) {
                            target = i + w - a;
                        }
                        else if (!lazy && x + a < w && x + a >= 0 && i + a < l && displaces(pixel.type, data[i + a].type)) {
                            target = i + a;
                        }
                        else if (!lazy && x - a < w && x - a >= 0 && i - a < l && displaces(pixel.type, data[i - a].type)) {
                            target = i - a;
                        }

                        break;

                    case Pixel.steam:
                        if (--pixel.decay <= 0) {
                            pixel.type = Math.random() < .4 ? Pixel.water : Pixel.air;
                            pixel.color = Pixel.getColor(pixel.type, pixel.tick);
                            break;
                        }

                        moves = [i - w, i - w + a, i - w - a, i - a, i + a];
                        moves.sort(() => Math.random() - .5);

                        for (let move of moves) {
                            if (move >= 0 && move < l && Math.abs(x - move % w) < 5 && displaces(pixel.type, data[move].type)) {
                                target = move;
                                break;
                            }
                        }
                        break;

                    case Pixel.sand:
                        if (i + w < l && displaces(pixel.type, data[i + w].type)) {
                            target = i + w;
                        }
                        else if (!lazy && x + a < w && x + a >= 0 && i + w + a < l && displaces(pixel.type, data[i + w + a].type)) {
                            target = i + w + a;
                        }
                        else if (!lazy && x - a < w && x - a >= 0 && i + w - a < l && displaces(pixel.type, data[i + w - a].type)) {
                            target = i + w - a;
                        }

                        break;
                }

                if (target != i) {
                    [data[i], data[target]] = [data[target], data[i]]
                    data[target].tick = tick;
                }

                data[i].tick = tick;
            }

            return world;
        }

        function render(world) {
            const { ctx, img, buf, renderWidth: w, renderHeight: h } = world;

            let data = img.data;

            let i = 0;
            for (const pixel of world.data) {
                [data[i * 4], data[i * 4 + 1], data[i * 4 + 2], data[i++ * 4 + 3]] = pixel.color;
            }

            ctx.clearRect(0, 0, w, h);

            buf.putImageData(img, 0, 0);
            ctx.drawImage(buf.canvas, 0, 0, w, h);

            i = 0;
            for (let button of world.buttons) {
                ctx.fillStyle = button.generator == Pixel.sand ? stringColor(sandColor(world.counters[Pixel.sand])) : button.fillStyle;
                ctx.fillRect(button.x, button.y, button.w, button.h);

                ctx.strokeStyle = i++ == world.activeButton
                    ? 'white'
                    : '#555';

                ctx.strokeRect(button.x + .5, button.y + .5, button.w, button.h);
            }
        }

        function add(data, w, x, y, type, counters) {
            const r = 6;
            const threshold = type == Pixel.air ? 1
                : type === Pixel.stone || type === Pixel.wood ? .95 : .2;


            switch (type) {
                default:
                    for (let i = 0; i < r * 2; ++i) {
                        for (let j = 0; j < r * 2; ++j) {

                            const dx = - r + j;
                            const dy = - r + i;

                            if (Math.random() < threshold) {
                                const d = (dx * dx + dy * dy) / (r * r);

                                if (d < 1 && (1 - d) * (1 - d) > Math.random())
                                    put(data, w, x + dx, y + dy, type, ++counters[type]);
                            }
                        }
                    }
                    break;
            }
        }

        function put(data, w, x, y, type, tick) {
            if (x >= 0 && x < w && y >= 0 && y * w + x < data.length && (type == Pixel.air || data[y * w + x].type == Pixel.air))
                data[y * w + x] = new Pixel(type, tick);
        }

        function sandColor(tick, vary) {
            let hue = (tick / 120) % 360;
            let sat = .7;
            let lig = .6;

            const p1 = 45;
            const p2 = 180;
            const p3 = 240;
            const p4 = 340;

            const w1 = (p2 - p1) / 2;
            const w2 = (p4 - p3) / 2;

            if (hue > p1 && hue < p2 || hue > p3 && hue < p4) sat *= .5;

            const dg = Math.abs((p2 + p1) / 2 - hue);
            const dp = Math.abs((p4 + p3) / 2 - hue);
            if (dg < w1) { sat *= dg / w1; lig += .35 * (1 - dg / w1) }
            if (dp < w2) { sat *= Math.pow(dp / w2, 2); lig -= .5 * (1 - Math.pow(dp / w2, 2)) }

            return hcy2rgb(floating(hue, vary ? 5 : 0), floating(sat, vary ? sat * .05 : 0), floating(lig, vary ? lig * .05 : 0))
        }

        function waterColor(vary) {
            return hcy2rgb(floating(200, vary ? 5 : 0), floating(.65, vary ? .03 : 0), floating(.6, vary ? .03 : 0))
        }

        function oilColor(vary) {
            return hcy2rgb(floating(20, vary ? 5 : 0), floating(.85, vary ? .03 : 0), floating(.3, vary ? .03 : 0))
        }

        function fireColor(vary) {
            return hcy2rgb(floating(15, vary ? 5 : 0), floating(.95, vary ? .03 : 0), floating(.5, vary ? .03 : 0))
        }

        function floating(v, dv) {
            dv = dv || 0;
            return dv > 0 ? v - dv + 2 * dv * Math.random() : v
        }

        function rnd(a, b) {
            return a + (b - a) * Math.random();
        }
    </script>
</body>

</html>